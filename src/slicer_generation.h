#include "surface_solns.h"

#ifndef SLICER_GENERATION_H
#define SLICER_GENERATION_H

/**
 * @brief A struct to store the parameters of the image slicer. See the struct
 * SLICE_PARAMS defined in surface_solns.h for a description of each slice parameter
 * (alpha, beta, gamma, cv, k, zp, syx, syz, sxy, sxz, u).
 */
typedef struct {
    int custom;          // Whether to set custom params for each slice (use custom DLL if true)
    int surface_type;    // 0 = rotationally symmetric conic; 1 = cylindrical conic
    int n_each;          // Number of slices per section
    int n_rows;          // Number of rows of sections
    int n_cols;          // Number of columns of sections
    int angle_mode;      // Pattern generated by gamma

    double dalpha;       // Change in alpha between rows in degrees
    double dbeta;        // Change in beta between columns in degrees
    double dgamma;       // Change in gamma between slices in degrees
    double gamma_offset; // Offset in gamma between rows

    double azps;         // Change in zp between slices
    double dsyx;         // Change in syx between rows
    double dsyz;         // Change in syz between rows
    double dsxy;         // Change in sxy between columns
    double dsxz;         // Change in sxz between columns
    double du;           // Change in u between rows

    double alpha_cen;    // alpha of central row (or avg of 2 central rows if n_rows is even)
    double beta_cen;     // beta of central column (or avg of 2 central columns if n_cols is even)
    double gamma_cen;    // gamma of central slice
    double syx_cen;      // syx of central section
    double syz_cen;      // syz of central section
    double sxy_cen;      // sxy of central section
    double sxz_cen;      // sxz of central section
    double u_cen;        // u of central section

    double dx;           // Slice size along x-axis
    double dy;           // Slice size along y-axis
    double cv;           // Curvature = 1 / R
    double k;            // Conic constant

    double gx_width;     // Width of gaps between columns along x-axis
    double gx_depth;     // Depth (z) of gaps between columns
    double gy_width;     // Width of gaps between slices/rows along y-axis
    double gy_depth;     // Depth (z) of gaps between slices/rows along y-axis
} IMAGE_SLICER_PARAMS;

/**
 * @brief A struct to store the bounds of a ray. The bounds are computed by the
 * function GetRayBounds.
 */
typedef struct {
    int nc_min;
    int ns_min;
    int nc_max;
    int ns_max;
    int sgnc;
    int sgns;
    double xmin;
    double ymin;
    double xmax;
    double ymax;
} RAY_BOUNDS;

/**
 * @brief Creates a linearly spaced array. This is akin to the numpy linspace
 * function in Python.
 * 
 * @param array Pointer to the array to store the values.
 * @param start Start value, inclusive.
 * @param end End value, exclusive.
 * @param n Number of points.
 */
void linspace(double *array, double start, double end, int n);

/**
 * @brief Validates image slicer parameters. If parameters are illegal, they
 * are modified to safe values.
 * 
 * @param p Pointer for image slicer parameters.
 * @return int 0 if the parameters are okay. 1 if the parameters were not okay
 *          and were modified.
 */
int ValidateSlicerParams(IMAGE_SLICER_PARAMS *p);

/**
 * @brief Checks whether the image slicer parameters are equal, member by member.
 * 
 * @param p1 First IMAGE_SLICER_PARAMS struct to compare.
 * @param p2 Second IMAGE_SLICER_PARAMS struct to compare.
 * @return int 1 if all members are equal, 0 otherwise.
 */
int IsParametersEqual(IMAGE_SLICER_PARAMS p1, IMAGE_SLICER_PARAMS p2);

IMAGE_SLICER_PARAMS MakeSlicerParamsFromCustom(double p_custom[]);

/**
 * @brief Get the appropriate functions for the surface type indicated by p.
 * 
 * @param transfer_dist_func Pointer to function that computes the ray transfer distance of a slice.
 * @param critical_xy_func Pointer to function that computes the critical point of a slice.
 * @param surf_normal_func Pointer to function that computes the surface normal of a slice.
 * @param transform_func Pointer to function that applies the transformation matrix of a slice.
 * @param pslice Slice parameters.
 * @param p Image slicer parameters.
 */
void GetSurfaceFuncs(TRANSFER_DIST_FUNC *transfer_dist_func, SURF_NORMAL_FUNC *surf_normal_func,
    CRITICAL_XY_FUNC *critical_xy_func, TRANSFORMATION_FUNC *transform_func, SLICE_PARAMS pslice, IMAGE_SLICER_PARAMS p);

/**
 * @brief Computes the size of the image slicer.
 * 
 * @param xsize Pointer for size of the image slicer along the x-axis.
 * @param ysize Pointer for size of the image slicer along the y-axis.
 * @param p Image slicer parameters.
 */
void GetSlicerSize(double *xsize, double *ysize, IMAGE_SLICER_PARAMS p);

/**
 * @brief Computes column, slice indices for a given set of x, y.
 * 
 * @param col_num Pointer for the column number.
 * @param slice_num Pointer for the slice number.
 * @param x x-coordinate.
 * @param y y-coordinate.
 * @param p Image slicer parameters.
 */
void GetSlicerIndex(int *col_num, int *slice_num, double x, double y, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Checks whether a point (x, y) is inside a gap.
 * 
 * @param in_xgap Pointer to store whether the point is inside a gap along x.
 * @param in_ygap Pointer to store whether the point is inside a gap along y.
 * @param x x-coordinate to check.
 * @param y y-coordinate to check.
 * @param p Image slicer parameters.
 * @param p_custom Custom slice parameters if applicable.
 */
void IsInsideSlicerGap(int *in_xgap, int *in_ygap, double x, double y, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Gets the indices of the slice to use for the paraxial ray trace.
 * 
 * @param col_num Pointer to store the column index.
 * @param slice_num Pointer to store the slice index.
 * @param active_x If 1, use the slice above the center line if there is an even number of slices.
 * @param active_y If 1, use the slice to the right of the center line if there is an even number of columns.
 * @param p Image slicer parameters.
 */
void GetParaxialSliceIndex(int *col_num, int *slice_num, int active_x, int active_y, IMAGE_SLICER_PARAMS p);

/**
 * @brief Computes the minimum and maximum u values for the image slicer.
 * 
 * @param umin Pointer to store the minimum u value.
 * @param umax Pointer to store the maximum u value.
 * @param p Image slicer parameters.
 * @param p_custom Custom slice parameters if applicable.
 */
void GetMinMaxU(double *umin, double *umax, IMAGE_SLICER_PARAMS p, double p_custom[]);

/** 
 * @brief Returns the parameters for a slice based on its indices.
* 
*   @param slice_num Slice index to compute parameters for.
*   @param col_num Column index to compute parameters for.
*   @param p Image slicer parameters.
*   @param p_custom Custom slice parameters if applicable.
**/
SLICE_PARAMS GetSliceParams(int slice_num, int col_num, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Calculates u for the given row index.
 * 
 * @param row_num Row index to compute u for.
 * @param p Image slicer parameters.
 * @param p_custom Custom slice parameters if applicable.
 * @return double The computed u value for the given row.
 */
double GetUForRow(int row_num, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Based on the definitions of standard mode, returns the parameters for
 * a slice based on its indices.
 * 
 * @param slice_num Slice index to compute parameters for.
 * @param col_num Column index to compute parameters for.
 * @param p Image slicer parameters.
 * @param p_custom Custom slice parameters if applicable.
 **/
SLICE_PARAMS GetSliceParamsStandard(int slice_num, int col_num, IMAGE_SLICER_PARAMS p);

/** @brief Computes the sag of the image slicer.
* 
*   @param x x-coordinate to evaluate.
*   @param y y-coordinate to evaluate.
*   @param p Image slicer parameters.
*   @param p_custom Custom slice parameters if applicable.
* 
*   @return The sag of the image slicer, or NAN if out of bounds.
**/
double ImageSlicerSag(double x, double y, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Finds an extremum of a slice within the bounds that it is defined for
 * this image slicer. An initial guess is used to determine which slice to check.
 * 
 * @param x0 Initial guess for the x-coordinate.
 * @param y0 Initial guess for the y-coordinate.
 * @param mode 0 for maximum, 1 for minimum.
 * @param p Image slicer parameters.
 * @param sag_func Function to compute the sag of a slice.
 * @param critical_xy_func Function to compute the critical point of a slice.
 * @return double Bounded maximum or minimum for a slice.
 */
double FindBoundedSliceExtremum(double x0, double y0, int mode, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Computes global extrema for the image slicer.
 * 
 * @param zmin Pointer to store the global minimum.
 * @param zmax Pointer to store the global maximum.
 * @param p Image slicer parameters.
 * @param sag_func Function to compute the sag of a slice.
 * @param critical_xy_func Function to compute the critical point of a slice.
 */
void FindSlicerGlobalExtrema(double *zmin, double *zmax, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Transfer equation for the entire image slicer. The roots of this function
 * give the transfer distance t.
 * 
 * @param t Transfer distance.
 * @param xt Starting x-coordinate of the ray.
 * @param yt Starting y-coordinate of the ray.
 * @param l Direction cosine along x.
 * @param m Direction cosine along y.
 * @param n Direction cosine along z.
 * @param p Image slicer parameters.
 * @param sag_func Function to compute the sag of a slice.
 * @return double The image slicer sag minus the computed z-coordinate at the surface (zs).
 */
double TransferFunction(double t, RAY_IN ray_in, IMAGE_SLICER_PARAMS p, double p_custom[]);

/**
 * @brief Computes the bounds of a ray.
 * 
 * @param ray_in Input ray parameters.
 * @param umin Minimum u value for the ray.
 * @param umax Maximum u value for the ray.
 * @param zmin Global minimum of the image slicer.
 * @param zmax Global maximum of the image slicer.
 * @param p Image slicer parameters.
 * @param p_custom Custom slice parameters if applicable.
 * @return RAY_BOUNDS The bounds of the ray.
 */
RAY_BOUNDS GetRayBounds(RAY_IN ray_in, double umin, double umax, double zmin, double zmax,
    IMAGE_SLICER_PARAMS p, void *p_custom);

int IsRayInBounds(int nc_min, int ns_min, int nc_max, int ns_max, double umax, double umin, IMAGE_SLICER_PARAMS p);

int IsSectionInBounds(int col_num, int row_num, double umin, double umax, IMAGE_SLICER_PARAMS p);

void CheckSliceSolution(RAY_OUT *ray_out, double tol, RAY_IN ray_in, int ns_test, int nc_test,
                           IMAGE_SLICER_PARAMS p, void *p_custom);

void CheckYWallCollision(RAY_OUT *ray_out, RAY_IN ray_in, int ns_test, int nc_test, int sgns,
    IMAGE_SLICER_PARAMS p, void *p_custom);

void CheckXWallCollision(RAY_OUT *ray_out, RAY_IN ray_in, int ns_test, int nc_test, int sgnc,
    IMAGE_SLICER_PARAMS p, void *p_custom);

void CalcNextCoords(double *x_next, double *y_next, int *code, RAY_IN ray_in, int sgnc, int sgns, int nc_test, int nr_test,
    double x_test, double y_test, double xmax, double ymax, IMAGE_SLICER_PARAMS p,
    void *p_custom);

void CalcNumSlicesToCheck(int sgnc, int sgns, int nc_test, int nr_test,
                           double x_test, double y_test,
                           double x_next, double y_next, int code,
                           IMAGE_SLICER_PARAMS p, void *p_custom,
                           int *n_stocheck, int *nc_new, int *nr_new);

/**
 * @brief Computes the transfered ray and surface normals for the image slicer.
 * 
 * @param ray_out Pointer for the output ray parameters.
 * @param ray_in Input ray parameters.
 * @param zmin Global minimum of the image slicer.
 * @param zmax Global maximum of the image slicer.
 * @param p Image slicer parameters.
 * @param trace_walls If 1, attempts to ray trace walls. If 0, walls are ignored.
 * @param sag_func Function to compute the sag of a slice.
 * @param transfer_dist_func Function to compute the transfer distance for a slice.
 * @param surf_normal_func Function to compute the surface normal of a slice.
 */
void RayTraceSlicer(RAY_OUT *ray_out, RAY_IN ray_in, double zmin, double zmax, double umin, double umax,
     int trace_walls, IMAGE_SLICER_PARAMS p, double p_custom[]);

void ParaxialRayTraceSlicer(RAY_OUT* ray_out, double* l_out, double* m_out, double* n_out,
    RAY_IN* ray_in, double n1, double n2, int active_x, int active_y,
    IMAGE_SLICER_PARAMS p, double p_custom[]);

#endif